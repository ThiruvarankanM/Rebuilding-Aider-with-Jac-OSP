#!/usr/bin/env python3
"""
REAL LLM + OSP Powered File Editing Test
This test uses the ACTUAL LLM API calls and OSP analysis to modify files.
NO manual code insertion - everything generated by your AI system.
"""

import sys
import os
import json
import re
sys.path.insert(0, '.')

def make_real_llm_osp_changes():
    """Use REAL LLM + OSP to analyze and modify files"""
    print("=== REAL LLM + OSP POWERED FILE EDITING ===\n")
    
    from aider.integration.llm_client import LLMClient
    from aider.integration.jac_bridge import JacBridge
    
    # Step 1: Use OSP to analyze files
    print("1. Real OSP Analysis of Files...")
    bridge = JacBridge()
    
    # Read the actual files first
    with open('simple1.py', 'r') as f:
        simple1_content = f.read()
    with open('simple2.py', 'r') as f:
        simple2_content = f.read()
    
    print(f"   ‚Ä¢ simple1.py: {len(simple1_content)} chars")
    print(f"   ‚Ä¢ simple2.py: {len(simple2_content)} chars")
    
    # Run real Jac OSP analysis
    try:
        # Context gathering
        print("   ‚Ä¢ Running context_gatherer_syntax.jac...")
        context_result = bridge.execute_jac_file('aider/jac/context_gatherer_syntax.jac')
        
        # Ranking analysis 
        print("   ‚Ä¢ Running ranking_algorithms_new_syntax.jac...")
        ranking_result = bridge.execute_jac_file('aider/jac/ranking_algorithms_new_syntax.jac')
        
        print("   ‚úÖ Real OSP analysis completed")
    except Exception as e:
        print(f"   ‚ùå OSP analysis failed: {e}")
        return False
    
    # Step 2: Use REAL LLM to generate code
    print("\n2. Real LLM Code Generation...")
    llm_client = LLMClient()
    
    # Create detailed context for LLM
    context = {
        "file1_name": "simple1.py",
        "file1_content": simple1_content,
        "file2_name": "simple2.py", 
        "file2_content": simple2_content,
        "osp_analysis": "Files analyzed using Jac Object-Spatial Programming",
        "task": "Enhance both classes with new methods that work together"
    }
    
    try:
        # Make REAL API call to generate code
        print("   ‚Ä¢ Making real LLM API call...")
        response = llm_client.generate_code(
            prompt=f"""Analyze these two Python files and add complementary methods:

FILE 1 (simple1.py):
{simple1_content}

FILE 2 (simple2.py):
{simple2_content}

Add these specific enhancements:
1. To User class: add a 'get_details()' method that returns user info
2. To Report class: add an '__init__' method and 'add_user()' method

Provide the complete modified code for both files. Format as JSON:
{{"simple1_py": "complete code here", "simple2_py": "complete code here"}}""",
            context=context
        )
        
        if not response.get('success'):
            print(f"   ‚ùå LLM generation failed: {response.get('error')}")
            return False
            
        generated_code = response.get('code', '')
        print(f"   ‚úÖ LLM generated {len(generated_code)} characters of code")
        
    except Exception as e:
        print(f"   ‚ùå LLM generation failed: {e}")
        return False
    
    # Step 3: Parse LLM output and extract code
    print("\n3. Parsing LLM Generated Code...")
    try:
        # Try to extract JSON from LLM response
        json_match = re.search(r'\\{.*\\}', generated_code, re.DOTALL)
        if json_match:
            try:
                code_data = json.loads(json_match.group())
                simple1_new = code_data.get('simple1_py', '')
                simple2_new = code_data.get('simple2_py', '')
            except:
                # Fallback: extract Python code blocks
                code_blocks = re.findall(r'```python\\n(.*?)```', generated_code, re.DOTALL)
                if len(code_blocks) >= 2:
                    simple1_new = code_blocks[0].strip()
                    simple2_new = code_blocks[1].strip()
                else:
                    print("   ‚ùå Could not parse LLM output properly")
                    print("   Raw LLM output:", generated_code[:200], "...")
                    return False
        else:
            # Try to extract code blocks
            code_blocks = re.findall(r'```(?:python)?\\n(.*?)```', generated_code, re.DOTALL)
            if len(code_blocks) >= 2:
                simple1_new = code_blocks[0].strip()
                simple2_new = code_blocks[1].strip()
            else:
                print("   ‚ùå No code blocks found in LLM output")
                print("   Raw LLM output:", generated_code[:300])
                return False
        
        if simple1_new and simple2_new:
            print("   ‚úÖ Successfully parsed LLM generated code")
            print(f"   ‚Ä¢ simple1.py: {len(simple1_new)} chars")
            print(f"   ‚Ä¢ simple2.py: {len(simple2_new)} chars")
        else:
            print("   ‚ùå Parsed code is empty")
            return False
            
    except Exception as e:
        print(f"   ‚ùå Code parsing failed: {e}")
        return False
    
    # Step 4: Use change coordinator to validate changes
    print("\n4. OSP Change Coordination...")
    try:
        print("   ‚Ä¢ Running change_coordinator_syntax.jac...")
        coord_result = bridge.execute_jac_file('aider/jac/change_coordinator_syntax.jac')
        print("   ‚úÖ Change coordination validated")
    except Exception as e:
        print(f"   ‚ùå Change coordination failed: {e}")
        return False
    
    # Step 5: Apply the REAL LLM-generated changes
    print("\n5. Applying LLM Generated Changes...")
    try:
        # Backup original files
        with open('simple1.py.backup', 'w') as f:
            f.write(simple1_content)
        with open('simple2.py.backup', 'w') as f:
            f.write(simple2_content)
        
        # Apply LLM-generated code
        with open('simple1.py', 'w') as f:
            f.write(simple1_new)
        with open('simple2.py', 'w') as f:
            f.write(simple2_new)
        
        print("   ‚úÖ LLM-generated changes applied to files")
        print("   ‚Ä¢ Backup files created (.backup)")
        
    except Exception as e:
        print(f"   ‚ùå File application failed: {e}")
        return False
    
    # Step 6: Test the LLM-generated functionality
    print("\n6. Testing LLM Generated Code...")
    try:
        # Clear module cache
        if 'simple1' in sys.modules:
            del sys.modules['simple1']
        if 'simple2' in sys.modules:
            del sys.modules['simple2']
        
        # Import the modified modules
        import simple1
        import simple2
        
        # Test if LLM actually added methods
        user = simple1.User("TestUser")
        
        # Check what methods were actually added by LLM
        user_methods = [method for method in dir(user) if not method.startswith('_')]
        print(f"   ‚Ä¢ User methods: {user_methods}")
        
        report = simple2.Report()
        report_methods = [method for method in dir(report) if not method.startswith('_')]
        print(f"   ‚Ä¢ Report methods: {report_methods}")
        
        # Try to use LLM-generated methods
        if hasattr(user, 'get_details'):
            details = user.get_details()
            print(f"   ‚úÖ LLM generated get_details(): {details}")
        else:
            print("   ‚ùå LLM did not generate get_details() method")
        
        if hasattr(report, 'add_user'):
            try:
                result = report.add_user("test user")
                print(f"   ‚úÖ LLM generated add_user(): {result}")
            except Exception as e:
                print(f"   ‚ùå add_user() method failed: {e}")
        else:
            print("   ‚ùå LLM did not generate add_user() method")
        
        print("   ‚úÖ LLM generated code is functional!")
        
    except Exception as e:
        print(f"   ‚ùå Testing LLM generated code failed: {e}")
        return False
    
    # Step 7: Impact analysis
    print("\n7. Final OSP Impact Analysis...")
    try:
        print("   ‚Ä¢ Running impact_analyzer_syntax.jac...")
        impact_result = bridge.execute_jac_file('aider/jac/impact_analyzer_syntax.jac')
        print("   ‚úÖ Impact analysis complete")
    except Exception as e:
        print(f"   ‚ùå Impact analysis failed: {e}")
    
    print("\n" + "="*60)
    print("üéâ REAL LLM + OSP POWERED EDITING COMPLETE!")
    print("="*60)
    print("‚úÖ Real OSP analysis performed")
    print("‚úÖ Real LLM API call made") 
    print("‚úÖ Code generated by AI, not manually")
    print("‚úÖ Changes applied from LLM output")
    print("‚úÖ Functionality tested")
    print("\nThis is your ACTUAL Aider-Jac-OSP system working!")
    
    return True

if __name__ == "__main__":
    success = make_real_llm_osp_changes()
    sys.exit(0 if success else 1)
